<!DOCTYPE html>
<meta charset="utf-8">
<style>

path {
  stroke: #000;
  fill-opacity: .8;
}

</style>
<body>
<!-- Blockspring Boilerplate CSS -->
<link rel="stylesheet" href="//www.graf.ly/graph_templates/boilerplate.css">

<!-- Blockspring Boilerplate JS -->
<script src="//www.graf.ly/graph_templates/boilerplate.js"></script>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script>
  Block.ready(renderStream)

  function renderStream(){
    var width = $(document).width(),
          height = $(document).height();

    // Update 1: Get CSV data from BlockSpring API (vars.csv.data)
    var csv = Block.vars.csv.data;

    // Update 2: Get headers from BlockSpring API (vars.csv.columnRoleMap)
    var valueHeader = Block.vars.csv.columnRoleMap.value[0];
    var seriesHeader = Block.vars.csv.columnRoleMap.series;

    // Update 3: Get unique values from BlockSpring API (vars.csv.columnMetaData)
    var uniqueSeries = d3.keys(Block.vars.csv.columnMetaData[seriesHeader].reverseFormatLibrary);
    
    var m = uniqueSeries.length; // number of series

    // Transform csv data into array of arrays.
    var dataObject = {};
    
    uniqueSeries.forEach(function(series){
      dataObject[series] = [];
    })

    csv.forEach(function(row){
      dataObject[row[seriesHeader]].push(row[valueHeader]);
    })

    var data = d3.values(dataObject);
    var n = data[0].length; // number of values assuming each series has equal # of values.

    // set scales for x and y positions, and area size.
    var x = d3.scale.linear()
        .domain([0, n - 1])
        .range([0, width]);

    var y = d3.scale.ordinal()
        .domain(d3.range(m))
        .rangePoints([0, height], 1);

    var z = d3.scale.linear()
        .domain(d3.extent(csv, function(d){ return d[valueHeader]; }))
        .range([0, height / (2*m)]);

    // set scales for color.
    var color = d3.scale.ordinal()
        .range(["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56"]);

    // instantiate area function.
    var area = d3.svg.area()
        .interpolate("basis")
        .x(function(d, i) { return x(i); })
        .y0(function(d) { return -z(d); })
        .y1(function(d) { return z(d); });

    // add svg to dom.
    var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height);

    // add area plots to dom.
    svg.selectAll("path")
        .data(data)
      .enter().append("path")
        .attr("transform", function(d, i) { return "translate(0," + y(i) + ")"; })
        .style("fill", function(d, i) { return color(i); })
        .attr("d", area);
  }
</script>